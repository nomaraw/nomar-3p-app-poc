(function(f,p){typeof exports=="object"&&typeof module<"u"?p(exports):typeof define=="function"&&define.amd?define(["exports"],p):(f=typeof globalThis<"u"?globalThis:f||self,p(f.AmazonConnectApp={}))})(this,function(f){"use strict";let p;function L(i){if(p)throw new Error("Global Provider is already set");p=i}function y(i){if(!p)throw new Error(i??"Attempted to get Global AmazonConnectProvider that has not been set.");return p}class v extends Error{constructor({reason:e,namespace:t,errorKey:n,details:s}){super(`ConnectError with error key "${n}"`),this.errorType=v.ErrorType,this.namespace=t,this.errorKey=n,this.reason=e,this.details=s??{}}}v.ErrorType="ConnectError";function m(i){try{return structuredClone(i)}catch{try{return JSON.parse(JSON.stringify(i))}catch(t){throw new v({errorKey:"deepCloneFailed",details:{actualError:t}})}}}class U{constructor({provider:e,loggerKey:t}){this.events=new Map,this.logger=new g({provider:e,source:"emitter",mixin:()=>({emitterLoggerKey:t})})}on(e,t){const n=this.events.get(e);n?n.add(t):this.events.set(e,new Set([t]))}off(e,t){const n=this.events.get(e);n&&(n.delete(t),n.size<1&&this.events.delete(e))}getHandlers(e){var t;return Array.from((t=this.events.get(e))!==null&&t!==void 0?t:[])}}var O=function(i,e,t,n){function s(r){return r instanceof t?r:new t(function(o){o(r)})}return new(t||(t=Promise))(function(r,o){function c(a){try{l(n.next(a))}catch(d){o(d)}}function u(a){try{l(n.throw(a))}catch(d){o(d)}}function l(a){a.done?r(a.value):s(a.value).then(c,u)}l((n=n.apply(i,e||[])).next())})};class N extends U{emit(e,t){return O(this,void 0,void 0,function*(){const n=this.getHandlers(e);yield Promise.allSettled(n.map(s=>O(this,void 0,void 0,function*(){try{yield s(t)}catch(r){this.logger.error("An error occurred when invoking event handler",{error:r,parameter:e})}})))})}}function B(i){const e=new Uint8Array(Math.ceil(i/2));return crypto.getRandomValues(e),Array.from(e,t=>t.toString(16).padStart(2,"0")).join("").substring(0,i)}function M(){return"randomUUID"in crypto?crypto.randomUUID():"10000000-1000-4000-8000-100000000000".replace(/[018]/g,i=>{const e=parseInt(i);return(e^crypto.getRandomValues(new Uint8Array(1))[0]&15>>e/4).toString(16)})}function F(i,e){return{request:(t,n)=>i.request(e,t,n),subscribe:(t,n)=>i.subscribe(Object.assign(Object.assign({},t),{namespace:e}),n),unsubscribe:(t,n)=>i.unsubscribe(Object.assign(Object.assign({},t),{namespace:e}),n),getProxyInfo:()=>({connectionStatus:i.connectionStatus,proxyType:i.proxyType}),onConnectionStatusChange:t=>i.onConnectionStatusChange(t),offConnectionStatusChange:t=>i.offConnectionStatusChange(t)}}class q{constructor(){this.idsByHandler=new Map,this.handlersById=new Map}add(e){const t=this.idsByHandler.get(e);if(t)return{handlerId:t};const n=M();return this.idsByHandler.set(e,n),this.handlersById.set(n,e),{handlerId:n}}getIdByHandler(e){var t;return(t=this.idsByHandler.get(e))!==null&&t!==void 0?t:null}getHandlerById(e){var t;return(t=this.handlersById.get(e))!==null&&t!==void 0?t:null}get(){return[...this.idsByHandler.entries()].map(([e,t])=>({handler:e,handlerId:t}))}delete(e){const t=this.idsByHandler.get(e);return t&&this.handlersById.delete(t),this.idsByHandler.delete(e),{isEmpty:this.idsByHandler.size<1}}size(){return this.idsByHandler.size}}class Q{constructor(){this.simpleSubscriptions=new Map,this.paramSubscriptions=new Map}add({namespace:e,key:t,parameter:n},s){var r,o,c,u,l;if(n){if(!this.paramSubscriptions.has(e)){this.paramSubscriptions.set(e,new Map([[t,new Map([[n,s]])]]));return}if(!(!((r=this.paramSubscriptions.get(e))===null||r===void 0)&&r.has(t))){(o=this.paramSubscriptions.get(e))===null||o===void 0||o.set(t,new Map([[n,s]]));return}(u=(c=this.paramSubscriptions.get(e))===null||c===void 0?void 0:c.get(t))===null||u===void 0||u.set(n,s)}else if(this.simpleSubscriptions.has(e))(l=this.simpleSubscriptions.get(e))===null||l===void 0||l.set(t,s);else{this.simpleSubscriptions.set(e,new Map([[t,s]]));return}}delete({namespace:e,key:t,parameter:n}){var s,r,o,c;n?!((r=(s=this.paramSubscriptions.get(e))===null||s===void 0?void 0:s.get(t))===null||r===void 0)&&r.delete(n)&&this.paramSubscriptions.get(e).get(t).size<1&&((o=this.paramSubscriptions.get(e))===null||o===void 0||o.delete(t),this.paramSubscriptions.get(e).size<1&&this.paramSubscriptions.delete(e)):!((c=this.simpleSubscriptions.get(e))===null||c===void 0)&&c.delete(t)&&this.simpleSubscriptions.get(e).size<1&&this.simpleSubscriptions.delete(e)}get({namespace:e,key:t,parameter:n}){var s,r,o;return n?(o=(r=this.paramSubscriptions.get(e))===null||r===void 0?void 0:r.get(t))===null||o===void 0?void 0:o.get(n):(s=this.simpleSubscriptions.get(e))===null||s===void 0?void 0:s.get(t)}getOrAdd(e,t){let n=this.get(e);return n||(n=t(),this.add(e,n)),n}addOrUpdate(e,t,n){let s=this.get(e);return s?s=n(s):s=t(),this.add(e,s),s}getAllSubscriptions(){const e=Array.from(this.simpleSubscriptions.keys()).flatMap(n=>Array.from(this.simpleSubscriptions.get(n).keys()).flatMap(s=>({namespace:n,key:s}))),t=Array.from(this.paramSubscriptions.keys()).flatMap(n=>Array.from(this.paramSubscriptions.get(n).keys()).flatMap(s=>Array.from(this.paramSubscriptions.get(n).get(s).keys()).flatMap(r=>({namespace:n,key:s,parameter:r}))));return[...e,...t]}}class K{constructor(){this.subscriptions=new Q}add(e,t){return this.subscriptions.getOrAdd(e,()=>new q).add(t)}get(e){var t,n;return(n=(t=this.subscriptions.get(e))===null||t===void 0?void 0:t.get())!==null&&n!==void 0?n:[]}getById(e,t){var n,s;return(s=(n=this.subscriptions.get(e))===null||n===void 0?void 0:n.getHandlerById(t))!==null&&s!==void 0?s:null}delete(e,t){var n,s;(s=(n=this.subscriptions.get(e))===null||n===void 0?void 0:n.delete(t).isEmpty)!==null&&s!==void 0&&s&&this.subscriptions.delete(e)}size(e){var t,n;return(n=(t=this.subscriptions.get(e))===null||t===void 0?void 0:t.size())!==null&&n!==void 0?n:0}isEmpty(e){return this.size(e)===0}getAllSubscriptions(){return this.subscriptions.getAllSubscriptions()}getAllSubscriptionHandlerIds(){return this.subscriptions.getAllSubscriptions().reduce((e,t)=>e.concat(this.get(t).map(({handlerId:n})=>({topic:t,handlerId:n}))),[])}}class ${constructor({sendMetric:e,metricName:t,metricOptions:n}){this.unit="Milliseconds",this.sendMetric=e,this.startTime=performance.now(),this.metricName=t,this.dimensions=n!=null&&n.dimensions?n.dimensions:{},this.optionalDimensions=n!=null&&n.optionalDimensions?n.optionalDimensions:{}}stopDurationCounter(){const e=Math.round(performance.now()-this.startTime);return this.sendMetric({metricName:this.metricName,unit:this.unit,value:e,dimensions:this.dimensions,optionalDimensions:this.optionalDimensions}),{duration:e}}}const G=30;function V(i,e){if(Object.keys(i).length+Object.keys(e??{}).length>G)throw new Error("Cannot add more than 30 dimensions to a metric")}function J({metricData:i,time:e,namespace:t},n){var s,r;return{type:"metric",namespace:t,metricName:i.metricName,unit:i.unit,value:i.value,time:e,dimensions:(s=i.dimensions)!==null&&s!==void 0?s:{},optionalDimensions:(r=i.optionalDimensions)!==null&&r!==void 0?r:{},messageOrigin:n}}class A{constructor(e){this._proxy=null,this.namespace=e.namespace,e.provider&&typeof e.provider=="function"?this.providerFactory=e.provider:this.provider=e.provider}recordSuccess(e,t){var n;const s=Object.assign({},(n=t==null?void 0:t.dimensions)!==null&&n!==void 0?n:{}),r=Object.assign(Object.assign({},t),{dimensions:s});this.recordCount(e,0,r)}recordError(e,t){var n;const s=Object.assign({},(n=t==null?void 0:t.dimensions)!==null&&n!==void 0?n:{}),r=Object.assign(Object.assign({},t),{dimensions:s});this.recordCount(e,1,r)}recordCount(e,t,n){this.sendMetric({metricName:e,unit:"Count",value:t,dimensions:n==null?void 0:n.dimensions,optionalDimensions:n==null?void 0:n.optionalDimensions})}startDurationCounter(e,t){return new $({sendMetric:this.sendMetric.bind(this),metricName:e,metricOptions:t})}sendMetric({metricName:e,unit:t,value:n,dimensions:s,optionalDimensions:r}){s&&V(s,r);const o={metricName:e,unit:t,value:n,dimensions:s,optionalDimensions:r},c=new Date;this.getProxy().sendMetric({metricData:o,time:c,namespace:this.namespace})}getProvider(){return this.provider||(this.provider=this.providerFactory?this.providerFactory():y()),this.provider}getProxy(){return this._proxy||(this._proxy=this.getProvider().getProxy()),this._proxy}}const W="clientTimeout";function X(i,e){const{namespace:t,command:n,data:s}=i;return{namespace:t,reason:"Client Timeout",details:{command:n,requestData:s,timeoutMs:e},errorKey:W}}const Y=30*1e3;function Z(i,e,t,n){const s=Math.max(1,Y);return new Promise((r,o)=>{let c=!1;const u=setTimeout(()=>{t({timeoutMs:s,request:i}),o(X(i,s)),c=!0},s);e(a=>{clearTimeout(u),c||(a.isError?o(new v(a)):r(a.data))})})}class ee{constructor(e){this.requestMap=new Map,this.logger=new g({provider:e,source:"core.requestManager"})}processRequest(e){const{requestId:t}=e;return Z(e,n=>this.requestMap.set(t,n),({request:n,timeoutMs:s})=>this.handleTimeout(n,s))}processResponse(e){const{requestId:t}=e,n=this.requestMap.get(t);if(!n){this.logger.error("Returned a response message with no handler",{message:e});return}n(e),this.requestMap.delete(t)}handleTimeout(e,t){const{requestId:n,namespace:s,command:r}=e;this.requestMap.delete(n),this.logger.error("Client request timeout",{requestId:n,namespace:s,command:r,timeoutMs:t})}}function te(i,e,t,n){const s=M();return{type:"request",namespace:i,command:e,requestId:s,data:t,messageOrigin:n}}var P=function(i,e){var t={};for(var n in i)Object.prototype.hasOwnProperty.call(i,n)&&e.indexOf(n)<0&&(t[n]=i[n]);if(i!=null&&typeof Object.getOwnPropertySymbols=="function")for(var s=0,n=Object.getOwnPropertySymbols(i);s<n.length;s++)e.indexOf(n[s])<0&&Object.prototype.propertyIsEnumerable.call(i,n[s])&&(t[n[s]]=i[n[s]]);return t};function I(i){try{switch(i.type){case"acknowledge":case"error":case"childConnectionClose":return i;case"childDownstreamMessage":return Object.assign(Object.assign({},i),{message:I(i.message)});case"publish":{const{data:e}=i,t=P(i,["data"]);return Object.assign({},t)}case"response":{if(i.isError)return Object.assign(Object.assign({},i),{details:{command:i.details.command}});{const{data:e}=i,t=P(i,["data"]);return Object.assign({},t)}}default:return i}}catch(e){return{messageDetails:"error when sanitizing downstream message",message:i,error:e}}}class ne{constructor(e,t){this.provider=e,this.relayChildUpstreamMessage=t,this.channels=new Map,this.logger=new g({provider:e,source:"childConnectionManager"})}addChannel(e){const{connectionId:t}=e;if(this.channels.has(t)){this.logger.error("Attempted to add child connection that already exists. No action",{connectionId:t});return}e.type==="iframe"?this.setupIframe(e):this.setupComponent(e),this.logger.debug("Child channel added",{connectionId:t,type:e.type})}updateChannelPort(e){const{connectionId:t}=e,n=this.channels.get(t);if(!n){this.logger.error("Attempted to update child connection that does not exist No action",{connectionId:t});return}if(n.type==="component"){this.logger.error("Attempted to update a component channel connection as MessagePort. This is not supported.",{connectionId:t});return}const s=n;s.port.onmessage=null,s.port.close();const r=Object.assign(Object.assign({},e),{type:"iframe"});this.setupIframe(r),this.logger.info("Updated child port",{connectionId:t})}setupIframe(e){const{connectionId:t,port:n,providerId:s}=e,r=this.createMessageHandler(t,s);n.addEventListener("message",r),n.start(),this.channels.set(t,{type:"iframe",port:n,handler:r,providerId:s}),this.relayChildUpstreamMessage({type:"childUpstream",connectionId:t,sourceProviderId:s,parentProviderId:this.provider.id,message:{type:"childConnectionReady"}})}setupComponent(e){const{connectionId:t,providerId:n,sendDownstreamMessage:s,setUpstreamMessageHandler:r}=e;r(c=>{this.relayChildUpstreamMessage({type:"childUpstream",sourceProviderId:n,parentProviderId:this.provider.id,connectionId:t,message:c})}),this.channels.set(t,{type:"component",providerId:n,sendDownstreamMessage:s,setUpstreamMessageHandler:r}),this.relayChildUpstreamMessage({type:"childUpstream",connectionId:t,sourceProviderId:n,parentProviderId:this.provider.id,message:{type:"childConnectionReady"}})}handleDownstreamMessage({connectionId:e,message:t,targetProviderId:n}){const s=this.channels.get(e);if(!s){this.logger.warn("Attempted to route downstream message to child channel that does not exist",{connectionId:e,message:I(t)});return}const{providerId:r}=s;if(r&&r!==n){this.logger.error("Downstream target message did not match target provider id. Not sending message.",{connectionId:e,targetProviderId:n,actualProviderId:r,message:I(t)});return}s.type==="iframe"?s.port.postMessage(t):s.sendDownstreamMessage(t)}handleCloseMessage({connectionId:e}){const t=this.channels.get(e);if(!t){this.logger.warn("Attempted to close child channel that was not found",{connectionId:e});return}if(t.type==="iframe"){const{port:n,handler:s}=t;n.removeEventListener("message",s),n.close()}this.channels.delete(e),this.logger.debug("Removed child channel",{connectionId:e,type:t.type})}createMessageHandler(e,t){return n=>this.relayChildUpstreamMessage({type:"childUpstream",sourceProviderId:t,parentProviderId:this.provider.id,connectionId:e,message:n.data})}}class se{constructor(e){this.errorHandlers=new Set,this.logger=new g({provider:e,source:"core.proxy.error"})}invoke(e){const{message:t,key:n,details:s,isFatal:r,connectionStatus:o}=e;this.logger.error(t,{key:n,details:s,isFatal:r,connectionStatus:o},{duplicateMessageToConsole:!0,remoteIgnore:!0}),[...this.errorHandlers].forEach(c=>{try{c(e)}catch(u){this.logger.error("An error occurred within a AmazonConnectErrorHandler",{handlerError:u,originalError:e})}})}onError(e){this.errorHandlers.add(e)}offError(e){this.errorHandlers.delete(e)}}class b{constructor({provider:e,sendHealthCheck:t,getUpstreamMessageOrigin:n}){this.connectionId=null,this.healthCheckInterval=null,this.healthCheckTimeout=null,this.sendHealthCheck=t,this.getUpstreamMessageOrigin=n,this.sendHealthCheckInterval=null,this.lastHealthCheckResponse=null,this._status="unknown",this.logger=new g({source:"core.proxy.health-check",provider:e,mixin:()=>({connectionId:this.connectionId})}),this.events=new N({provider:e,loggerKey:"core.proxy.health-check"})}get status(){return this._status}get isRunning(){return this.sendHealthCheckInterval!==null}get lastCheckCounter(){var e,t;return(t=(e=this.lastHealthCheckResponse)===null||e===void 0?void 0:e.counter)!==null&&t!==void 0?t:null}get lastCheckTime(){var e,t;return(t=(e=this.lastHealthCheckResponse)===null||e===void 0?void 0:e.time)!==null&&t!==void 0?t:null}start({healthCheckInterval:e,connectionId:t}){if(this.connectionId=t,this.healthCheckInterval=e,this.clearInterval(),e<=0){this.logger.debug("Health check disabled");return}if(e<1e3){this.logger.error("Health check interval is less than 1 second. Not running",{interval:e});return}this.sendHealthCheckMessage(),this.sendHealthCheckInterval=setInterval(()=>this.sendHealthCheckMessage(),e),this.startTimeout()}stop(){this.clearInterval(),this.clearTimeout()}handleResponse(e){this.setHealthy({time:e.time,counter:e.counter})}sendHealthCheckMessage(){this.sendHealthCheck({type:"healthCheck",messageOrigin:this.getUpstreamMessageOrigin()})}startTimeout(){if(!this.healthCheckInterval){this.logger.error("Health check interval not set. Cannot start timeout");return}this.clearTimeout(),this.healthCheckTimeout=setTimeout(()=>{this.setUnhealthy()},this.healthCheckInterval*3)}clearInterval(){this.sendHealthCheckInterval&&(clearInterval(this.sendHealthCheckInterval),this.sendHealthCheckInterval=null)}clearTimeout(){this.healthCheckTimeout&&(clearTimeout(this.healthCheckTimeout),this.healthCheckTimeout=null)}setUnhealthy(){if(this._status!=="unhealthy"){const e=this._status;this.logger.info("Connection unhealthy",{previousStatus:e}),this._status="unhealthy",this.emitStatusChanged("unhealthy",e)}}setHealthy(e){if(this.lastHealthCheckResponse=Object.assign({},e),this._status!=="healthy"){const t=this._status;this.logger.debug("Connection healthy",{previousStatus:t}),this._status="healthy",this.emitStatusChanged("healthy",t)}this.startTimeout()}emitStatusChanged(e,t){var n,s,r,o;this.events.emit(b.statusChangedKey,{status:e,previousStatus:t,lastCheckTime:(s=(n=this.lastHealthCheckResponse)===null||n===void 0?void 0:n.time)!==null&&s!==void 0?s:null,lastCheckCounter:(o=(r=this.lastHealthCheckResponse)===null||r===void 0?void 0:r.counter)!==null&&o!==void 0?o:null})}onStatusChanged(e){this.events.on(b.statusChangedKey,e)}offStatusChanged(e){this.events.off(b.statusChangedKey,e)}}b.statusChangedKey="statusChanged";class ie{constructor(e){this.status="notConnected",this.changeHandlers=new Set,this.logger=new g({source:"core.proxy.connection-status-manager",provider:e,mixin:()=>({status:this.status})})}getStatus(){return this.status}update(e){this.status=e.status,this.logger.trace("Proxy Connection Status Changed",{status:e.status}),[...this.changeHandlers].forEach(t=>{try{t(e)}catch(n){this.logger.error("An error occurred within a ProxyConnectionChangedHandler",{error:n})}})}onChange(e){this.changeHandlers.add(e)}offChange(e){this.changeHandlers.delete(e)}}var re=function(i,e,t,n){function s(r){return r instanceof t?r:new t(function(o){o(r)})}return new(t||(t=Promise))(function(r,o){function c(a){try{l(n.next(a))}catch(d){o(d)}}function u(a){try{l(n.throw(a))}catch(d){o(d)}}function l(a){a.done?r(a.value):s(a.value).then(c,u)}l((n=n.apply(i,e||[])).next())})},oe=function(i,e){var t={};for(var n in i)Object.prototype.hasOwnProperty.call(i,n)&&e.indexOf(n)<0&&(t[n]=i[n]);if(i!=null&&typeof Object.getOwnPropertySymbols=="function")for(var s=0,n=Object.getOwnPropertySymbols(i);s<n.length;s++)e.indexOf(n[s])<0&&Object.prototype.propertyIsEnumerable.call(i,n[s])&&(t[n[s]]=i[n[s]]);return t};class ae{constructor(e){this.provider=e,this.logger=new g({source:"core.proxy",provider:e,mixin:()=>({proxyType:this.proxyType,connectionId:this.connectionId})}),this.requestManager=new ee(e),this.status=new ie(e),this.errorService=new se(e),this.upstreamMessageQueue=[],this.connectionEstablished=!1,this.isInitialized=!1,this.subscriptions=new K,this.connectionId=null,this.channelManager=new ne(e,this.sendOrQueueMessageToSubject.bind(this)),this.healthCheck=new b({provider:e,sendHealthCheck:this.sendOrQueueMessageToSubject.bind(this),getUpstreamMessageOrigin:this.getUpstreamMessageOrigin.bind(this)})}init(){if(this.isInitialized)throw new Error("Proxy already initialized");this.isInitialized=!0,this.initProxy()}request(e,t,n,s){const r=te(e,t,n,s??this.getUpstreamMessageOrigin()),o=this.requestManager.processRequest(r);return this.sendOrQueueMessageToSubject(r),o}subscribe(e,t,n){const{handlerId:s}=this.subscriptions.add(e,t),r={type:"subscribe",topic:e,messageOrigin:n??this.getUpstreamMessageOrigin(),handlerId:s};this.sendOrQueueMessageToSubject(r)}unsubscribe(e,t,n){if(this.subscriptions.delete(e,t),this.subscriptions.isEmpty(e)){const s={type:"unsubscribe",topic:e,messageOrigin:n??this.getUpstreamMessageOrigin()};this.sendOrQueueMessageToSubject(s)}}log(e){const t=de(e,this.addContextToLogger(),this.getUpstreamMessageOrigin());this.sendOrQueueMessageToSubject(t)}sendLogMessage(e){if(e.type!=="log"){this.logger.error("Attempted to send invalid log message",{message:e});return}e.context=Object.assign(Object.assign({},e.context),this.addContextToLogger()),this.sendOrQueueMessageToSubject(e)}sendMetric({metricData:e,time:t,namespace:n}){const s=J({metricData:e,time:t,namespace:n},this.getUpstreamMessageOrigin());this.sendOrQueueMessageToSubject(s)}sendMetricMessage(e){if(e.type!=="metric"){this.logger.error("Attempted to send invalid metric message",{metricMessage:e});return}this.sendOrQueueMessageToSubject(e)}sendOrQueueMessageToSubject(e){this.connectionEstablished?this.sendMessageToSubject(e):this.upstreamMessageQueue.push(e)}consumerMessageHandler(e){if(!this.isInitialized){this.logger.error("Attempted to process message from subject prior to proxy being initializing. Message not processed",{originalMessageEventData:e.data});return}const{data:t}=e;if(!("type"in t)){this.logger.warn("Unknown inbound message",{originalMessageEventData:t});return}const n=t;this.handleMessageFromSubject(n)}handleMessageFromSubject(e){this.handleDefaultMessageFromSubject(e)}handleDefaultMessageFromSubject(e){switch(e.type){case"acknowledge":this.handleConnectionAcknowledge(e);break;case"response":this.handleResponse(e);break;case"publish":this.handlePublish(e);break;case"error":this.handleError(e);break;case"childDownstreamMessage":this.channelManager.handleDownstreamMessage(e);break;case"childConnectionClose":this.channelManager.handleCloseMessage(e);break;case"healthCheckResponse":this.healthCheck.handleResponse(e);break;default:this.logger.error("Unknown inbound message",{originalMessageEventData:e});return}}handleConnectionAcknowledge(e){for(this.connectionId=e.connectionId,this.logger.debug("Connection acknowledged by subject",{connectionId:e.connectionId,queuedMessageCount:this.upstreamMessageQueue.length,status:e.status}),this.status.update({status:"ready",connectionId:e.connectionId}),this.connectionEstablished=!0;this.upstreamMessageQueue.length;){const t=this.upstreamMessageQueue.shift();this.sendMessageToSubject(t)}this.healthCheck.start(e),this.logger.debug("Proxy connection ready",{connectionId:this.connectionId})}handleResponse(e){this.requestManager.processResponse(e)}handlePublish(e){const{handlerId:t,topic:n}=e;if(t){const s=this.subscriptions.getById(n,t);s&&this.handleAsyncSubscriptionHandlerInvoke({handler:s,handlerId:t},e)}else this.subscriptions.get(n).map(s=>void this.handleAsyncSubscriptionHandlerInvoke(s,e))}handleError(e){if(e.isFatal){const{message:t,type:n}=e,s=oe(e,["message","type"]);this.status.update({status:"error",reason:t,details:s})}this.publishError({message:e.message,key:e.key,details:e.details,isFatal:e.isFatal,proxyStatus:e.status})}publishError(e){const t=Object.assign(Object.assign({},e),{connectionStatus:this.connectionStatus});this.errorService.invoke(t)}handleAsyncSubscriptionHandlerInvoke(e,t){return re(this,arguments,void 0,function*({handler:n,handlerId:s},{topic:r,data:o}){try{yield n(o)}catch(c){this.logger.error("An error occurred when handling subscription",{topic:r,error:c,handlerId:s})}})}get connectionStatus(){return this.status.getStatus()}onError(e){this.errorService.onError(e)}offError(e){this.errorService.offError(e)}onConnectionStatusChange(e){this.status.onChange(e)}offConnectionStatusChange(e){this.status.offChange(e)}onHealthCheckStatusChanged(e){this.healthCheck.onStatusChanged(e)}offHealthCheckStatusChanged(e){this.healthCheck.offStatusChanged(e)}addChildChannel(e){this.addChildIframeChannel(e)}addChildIframeChannel(e){this.channelManager.addChannel(Object.assign(Object.assign({},e),{type:"iframe"}))}addChildComponentChannel(e){this.channelManager.addChannel(Object.assign(Object.assign({},e),{type:"component"}))}updateChildIframeChannelPort(e){this.channelManager.updateChannelPort(e)}updateChildChannelPort(e){this.updateChildIframeChannelPort(e)}getConnectionId(){return this.connectionId?Promise.resolve(this.connectionId):new Promise((e,t)=>{let n;const s=r=>{r.status==="ready"&&(this.offConnectionStatusChange(s),clearInterval(n),e(r.connectionId))};n=setTimeout(()=>{this.logger.error("Timeout getting connection id"),this.offConnectionStatusChange(s),t(new Error("Timeout getting connectionId"))},10*1e3),this.onConnectionStatusChange(s)})}resetConnection(e){this.logger.debug("Resetting connection",{reason:e,connectionId:this.connectionId}),this.connectionEstablished=!1,this.status.update({status:"reset",reason:e});const{subscriptionHandlerCount:t}=this.restoreAllHandler();this.logger.info("Resetting proxy",{reason:e,subscriptionHandlerCount:t}),this.logger.debug("Connection reset complete, restoring handlers",{subscriptionHandlerCount:t})}restoreAllHandler(){var e;const t=this.subscriptions.getAllSubscriptionHandlerIds();return t==null||t.map(({topic:n,handlerId:s})=>({type:"subscribe",topic:n,messageOrigin:this.getUpstreamMessageOrigin(),handlerId:s})).forEach(n=>this.sendOrQueueMessageToSubject(n)),{subscriptionHandlerCount:(e=t==null?void 0:t.length)!==null&&e!==void 0?e:-1}}unsubscribeAllHandlers(){var e;const t=this.subscriptions.getAllSubscriptionHandlerIds();this.logger.info("Unsubscribing all handlers from proxy",{subscriptionHandlerCount:(e=t==null?void 0:t.length)!==null&&e!==void 0?e:-1}),t==null||t.map(({topic:n})=>({type:"unsubscribe",topic:n,messageOrigin:this.getUpstreamMessageOrigin()})).forEach(n=>this.sendOrQueueMessageToSubject(n))}}class S{constructor(e,t){this.timeoutMs=t,this.onCancelled=e,this.timeout=setTimeout(()=>this.handleCancel(),this.timeoutMs),this.status="running",this.logger=new g({source:"core.utility.timeout-tracker",mixin:()=>({timeoutMs:this.timeoutMs,timeoutTrackerStatus:this.status})})}static start(e,t){return new S(e,t)}complete(){switch(this.status){case"running":return this.handleComplete();case"completed":return this.logger.debug("TimeoutTracker already marked complete. No action."),!0;case"cancelled":return this.logger.info("Attempted to complete a TimeoutTracker that has already been cancelled"),!1}}isCancelled(){return this.status==="cancelled"}getStatus(){return this.status}handleCancel(){switch(this.status){case"running":this.status="cancelled",this.logger.info("TimeoutTracker has timed out. Invoking onCancelled Handler"),this.invokeOnCancelled();break;case"completed":this.logger.debug("Cancel operation for TimerTracker invoked after already completed. No action.");break;default:throw new Error("Cancel operation in TimerTracker called during an unexpected time.")}}handleComplete(){return this.status="completed",clearTimeout(this.timeout),!0}invokeOnCancelled(){try{this.onCancelled({timeoutMs:this.timeoutMs})}catch(e){this.logger.error("Error when attempting to invoke TimeoutTrackerCancelledHandler",{error:e})}}}var h;(function(i){i[i.trace=1]="trace",i[i.debug=2]="debug",i[i.info=3]="info",i[i.warn=4]="warn",i[i.error=5]="error"})(h||(h={}));function ce(i,e,t){if(t)switch(i){case h.error:console.error(e,t);break;case h.warn:console.warn(e,t);break;case h.info:console.info(e,t);break;case h.debug:console.debug(e,t);break;case h.trace:console.trace(e,t);break;default:console.log(e,t);break}else switch(i){case h.error:console.error(e);break;case h.warn:console.warn(e);break;case h.info:console.info(e);break;case h.debug:console.debug(e);break;case h.trace:console.trace(e);break;default:console.log(e);break}}class j{constructor(e){this.mixin=e}getTransformedData(e,t){return this.mixin?Object.assign(Object.assign({},t??{}),this.mixin(t??{},e)):t}}class g{constructor(e){this._proxy=null,this._logToConsoleLevel=null,this.loggerId=B(8),typeof e=="string"?(this.source=e,this.dataTransformer=new j(void 0)):(this.source=e.source,e.provider&&typeof e.provider=="function"?this.providerFactory=e.provider:this.provider=e.provider,this.dataTransformer=new j(e.mixin),this.logOptions=e.options)}trace(e,t,n){this.log(h.trace,e,t,n)}debug(e,t,n){this.log(h.debug,e,t,n)}info(e,t,n){this.log(h.info,e,t,n)}warn(e,t,n){this.log(h.warn,e,t,n)}error(e,t,n){this.log(h.error,e,t,n)}log(e,t,n,s){const r=this.dataTransformer.getTransformedData(e,n);this.ignoreRemote(s)||this.getProxy().log({level:e,source:this.source,loggerId:this.loggerId,message:t,data:r}),this.applyDuplicateMessageToConsole(e,s)&&ce(e,t,r)}getProvider(){return this.provider||(this.provider=this.providerFactory?this.providerFactory():y()),this.provider}getProxy(){return this._proxy||(this._proxy=this.getProvider().getProxy()),this._proxy}applyDuplicateMessageToConsole(e,t){return(t==null?void 0:t.duplicateMessageToConsole)||this.getLogConsoleLevel()<=e}getLogConsoleLevel(){var e,t,n,s;return this._logToConsoleLevel||(this._logToConsoleLevel=!((e=this.logOptions)===null||e===void 0)&&e.minLogToConsoleLevelOverride?this.logOptions.minLogToConsoleLevelOverride:(s=(n=(t=this.getProvider().config)===null||t===void 0?void 0:t.logging)===null||n===void 0?void 0:n.minLogToConsoleLevel)!==null&&s!==void 0?s:h.error),this._logToConsoleLevel}ignoreRemote(e){var t,n,s;return((n=(t=this.logOptions)===null||t===void 0?void 0:t.remoteIgnore)!==null&&n!==void 0?n:!1)||((s=e==null?void 0:e.remoteIgnore)!==null&&s!==void 0?s:!1)}}function le(i){if(i)try{return m(i)}catch{return{error:"Data failed to sanitize. The original data is not available"}}}function de({level:i,source:e,message:t,loggerId:n,data:s},r,o){const c=le(s);return{type:"log",level:i,time:new Date,source:e,message:t,loggerId:n,data:c,context:r,messageOrigin:o}}class x{constructor({config:e,proxyFactory:t}){if(this._id=M(),!t)throw new Error("Attempted to get Proxy before setting up factory");if(!e)throw new Error("Failed to include config");this.proxyFactory=t,this._config=e}get id(){return this._id}getProxy(){return this.proxy||(this.proxy=this.proxyFactory(this),this.proxy.init()),this.proxy}get config(){return Object.assign({},this._config)}onError(e){this.getProxy().onError(e)}offError(e){this.getProxy().offError(e)}static initializeProvider(e){if(this.isInitialized){const t="Attempted to initialize provider more than one time.",n={};try{const s=y();new g({source:"core.amazonConnectProvider.init",provider:s}).error(t)}catch(s){n.loggingError=s==null?void 0:s.message}throw new v({errorKey:"attemptInitializeMultipleProviders",reason:t,details:n})}return L(e),this.isInitialized=!0,e.getProxy(),e}}x.isInitialized=!1;class he{constructor(e,t){this.engineContext=e,this.moduleNamespace=t}get proxy(){if(!this.moduleProxy){const e=this.engineContext.getProvider().getProxy(),t=this.moduleNamespace;this.moduleProxy=F(e,t)}return this.moduleProxy}getProvider(){return this.engineContext.getProvider()}createLogger(e){return typeof e=="object"?new g(Object.assign(Object.assign({},e),{provider:()=>this.engineContext.getProvider()})):new g({source:e,provider:()=>this.engineContext.getProvider()})}createMetricRecorder(e){return typeof e=="object"?new A(Object.assign(Object.assign({},e),{provider:()=>this.engineContext.getProvider()})):new A({namespace:e,provider:()=>this.engineContext.getProvider()})}}class H{constructor(e){this._provider=e}getProvider(){return this._provider?this._provider:y()}getModuleContext(e){return new he(this,e)}}const ue="1.0.9";class k extends H{constructor({provider:e,instanceId:t,config:n,parameters:s,contactScope:r,scope:o,launchedBy:c}){super(e),this.appInstanceId=t,this.instanceId=t,this.config=n,this.appConfig=n,this.contactScope=r,this.scope=o,this.parameters=s,this.launchedBy=c??{type:"unknown"}}}var E=function(i,e,t,n){function s(r){return r instanceof t?r:new t(function(o){o(r)})}return new(t||(t=Promise))(function(r,o){function c(a){try{l(n.next(a))}catch(d){o(d)}}function u(a){try{l(n.throw(a))}catch(d){o(d)}}function l(a){a.done?r(a.value):s(a.value).then(c,u)}l((n=n.apply(i,e||[])).next())})};class D{constructor(e){this.provider=e,this.state={isRunning:!1},this.isCreated=!1,this.isDestroyed=!1,this.logger=new g({source:"app.lifecycleManager",provider:e,mixin:()=>({state:this.state,isCreated:this.isCreated,isDestroyed:this.isDestroyed})})}get appState(){return Object.assign({},this.state)}handleCreate(e){return E(this,void 0,void 0,function*(){var t;if(this.isDestroyed){this.logger.error("An attempt was Create after a Destroy. No Action",{instanceId:e.context.instanceId});return}if(this.isCreated){this.logger.error("An attempt was invoke Create after it was already invoked. No Action",{instanceId:e.context.instanceId});return}if(this.logger.debug("Begin Lifecycle Create",{instanceId:e.context.instanceId}),!(!((t=this.provider.config)===null||t===void 0)&&t.onCreate)){const s="App did not specify an onCreated handler. This is required. Closing app",r={appInstanceId:e.context.instanceId,instanceId:e.context.instanceId};this.logger.error(s,{instanceId:e.context.instanceId}),this.provider.sendFatalError(s,r);return}const{success:n}=yield this.handleLifecycleChange(Object.assign(Object.assign({},e),{stage:"create"}),s=>this.provider.config.onCreate(s),!0);n&&(this.isCreated=!0,this.sendLifecycleHandlerCompletedMessage(e.context.instanceId,"create"))})}handleLifecycleChange(e,t,n){return E(this,void 0,void 0,function*(){let s=!1;try{yield t(e),s=!0}catch(r){const{instanceId:o}=e.context;if(n){const c=`An fatal error occurred when handling a ${e.stage} lifecycle action. Closing app`;this.logger.error(c,{instanceId:o,error:r}),this.provider.sendFatalError(c,r)}else this.logger.error(`An error occurred when handling a ${e.stage} lifecycle action.`,{instanceId:o,error:r})}return{success:s}})}sendLifecycleHandlerCompletedMessage(e,t){this.logger.debug(`Sending lifecycle ${t} completed signal`),this.provider.getProxy().sendLifecycleHandlerCompleted(e,t)}}var T=function(i,e,t,n){function s(r){return r instanceof t?r:new t(function(o){o(r)})}return new(t||(t=Promise))(function(r,o){function c(a){try{l(n.next(a))}catch(d){o(d)}}function u(a){try{l(n.throw(a))}catch(d){o(d)}}function l(a){a.done?r(a.value):s(a.value).then(c,u)}l((n=n.apply(i,e||[])).next())})};class ge extends D{constructor(e){super(e),this.startHandlers=new Set,this.stopHandlers=new Set}handleLifecycleChangeMessage(e){const t=new k({provider:this.provider,instanceId:e.instanceId,config:e.config,parameters:e.parameters,contactScope:e.contactScope,scope:e.scope,launchedBy:e.launchedBy});this.state.instanceId=e.instanceId,this.state.appInstanceId=e.instanceId,this.state.config=e.config,this.state.appConfig=e.config,this.state.contactScope=e.contactScope;const n={context:t};switch(e.stage){case"create":return this.handleCreate(n);case"start":return this.handleStart(n);case"stop":return this.handleStop(n);case"destroy":return this.handleDestroy(n)}}onStart(e,t){this.startHandlers.add(e),t!=null&&t.invokeIfRunning&&this.state.isRunning&&this.handleLifecycleChange(Object.assign(Object.assign({},this.getAppLifecycleChangeParams()),{stage:"start"}),n=>e(n),!1)}onStop(e){this.stopHandlers.add(e)}offStart(e){this.startHandlers.delete(e)}offStop(e){this.stopHandlers.delete(e)}handleStart(e){return T(this,void 0,void 0,function*(){if(this.isDestroyed){this.logger.error("An attempt was Start after a Destroy. No Action",{appInstanceId:e.context.instanceId});return}if(!this.isCreated){this.logger.error("An attempt was invoke Start before Create. No Action",{appInstanceId:e.context.instanceId});return}this.state.isRunning=!0,this.logger.info("Begin Lifecycle Start");const t=yield Promise.all([...this.startHandlers].map(n=>this.handleLifecycleChange(Object.assign(Object.assign({},e),{stage:"start"}),s=>n(s),!1)));this.logger.debug("Completed all start handlers",{count:this.startHandlers.size,errorCount:t.filter(({success:n})=>!n).length})})}handleStop(e){return T(this,void 0,void 0,function*(){if(this.isDestroyed){this.logger.error("An attempt was Stop after a Destroy. No Action",{appInstanceId:e.context.instanceId});return}if(!this.isCreated){this.logger.error("An attempt was invoke Stop before Create. No Action",{appInstanceId:e.context.instanceId});return}this.state.isRunning=!1,this.logger.info("Begin Lifecycle Stop");const t=yield Promise.all([...this.stopHandlers].map(n=>this.handleLifecycleChange(Object.assign(Object.assign({},e),{stage:"stop"}),s=>n(s),!1)));this.logger.debug("Completed all stop handlers",{count:this.stopHandlers.size,errorCount:t.filter(({success:n})=>!n).length})})}handleDestroy(e){return T(this,void 0,void 0,function*(){if(this.isDestroyed){this.logger.error("An attempt was invoke Destroy multiple times. No Action",{appInstanceId:e.context.instanceId});return}if(!this.isCreated){this.logger.error("An attempt was invoke Destroy before Create. No Action",{appInstanceId:e.context.instanceId});return}this.isDestroyed=!0,this.state.isRunning=!1,this.logger.info("Begin Lifecycle Destroy");const{config:t}=this.provider,{success:n}=yield this.handleLifecycleChange(Object.assign(Object.assign({},e),{stage:"destroy"}),s=>t.onDestroy?t.onDestroy(s):Promise.resolve(),!0);n&&this.sendLifecycleHandlerCompletedMessage(e.context.instanceId,"destroy")})}getAppLifecycleChangeParams(){return{context:new k({provider:this.provider,instanceId:this.state.instanceId,config:this.state.config,contactScope:this.state.contactScope,scope:this.state.scope,parameters:this.state.parameters,launchedBy:this.state.launchedBy})}}}function pe(i){var e,t;return Math.max(1,Math.min(6e4,(t=(e=i.workspace)===null||e===void 0?void 0:e.connectionTimeout)!==null&&t!==void 0?t:5e3))}class R extends ae{constructor(e,t){super(e),this.channel=new MessageChannel,this.lifecycleManager=t,this.appLogger=new g({source:"app.appProxy",provider:e})}get proxyType(){return"AppProxy"}sendLifecycleHandlerCompleted(e,t){const n={type:"appLifecycleHandlerCompleted",stage:t,appInstanceId:e};this.sendOrQueueMessageToSubject(n)}tryCloseApp(e,t,n){const s={type:"closeApp",isFatalError:t??!1,message:e,data:n};this.sendOrQueueMessageToSubject(s)}sendServiceError(e,t){const n={type:"serviceError",message:e,data:t};this.sendOrQueueMessageToSubject(n)}publish(e,t){const n={type:"appPublish",topic:e,data:t};this.sendOrQueueMessageToSubject(n)}initProxy(){const e={type:"connect-app-host-init",sdkVersion:ue,providerId:this.provider.id};this.status.update({status:"initializing"}),this.channel.port1.onmessage=t=>this.consumerMessageHandler(t),this.connectionTimer=S.start(this.connectionTimeout.bind(this),pe(this.provider.config)),window.parent.postMessage(e,"*",[this.channel.port2]),this.appLogger.debug("Send connect message to configure proxy")}sendMessageToSubject(e){this.channel.port1.postMessage(e)}getUpstreamMessageOrigin(){if(document!=null&&document.location){const{origin:e,pathname:t}=document.location;return{_type:"app",providerId:this.provider.id,origin:e,path:t}}else return{_type:"app",providerId:this.provider.id,origin:"unknown",path:"unknown"}}handleConnectionAcknowledge(e){if(!this.connectionTimer.complete()){this.appLogger.error("Workspace connection acknowledge received after timeout. App is not connected to workspace.",{timeout:this.connectionTimer.timeoutMs});return}super.handleConnectionAcknowledge(e)}handleMessageFromSubject(e){switch(e.type){case"appLifecycle":this.lifecycleManager.handleLifecycleChangeMessage(e).catch(t=>{this.appLogger.error("An error occurred when invoking handleLifecycleChangeMessage",{error:t})});break;default:super.handleMessageFromSubject(e)}}connectionTimeout(e){this.status.update({status:"error",reason:"Workspace connection timeout",details:Object.assign({},e)}),this.publishError({message:"App failed to connect to workspace in the allotted time",key:"workspaceConnectTimeout",details:Object.assign({},e),isFatal:!0,proxyStatus:{initialized:!1}})}addContextToLogger(){const{isRunning:e}=this.lifecycleManager.appState;if(document!=null&&document.location){const{origin:t,pathname:n}=document.location;return{appIsRunning:e,app:{origin:t,path:n}}}else return{appIsRunning:e,app:{origin:"unknown",path:"unknown"}}}}class C extends x{constructor(e){super({config:e,proxyFactory:()=>this.createProxy()}),this.lifecycleManager=new ge(this),this.logger=new g({provider:this,source:"app.provider"})}static init(e){const t=new C(e);return C.initializeProvider(t),{provider:t}}static get default(){return y("AmazonConnectApp has not been initialized")}createProxy(){return new R(this,this.lifecycleManager)}onStart(e,t){this.lifecycleManager.onStart(e,t)}onStop(e){this.lifecycleManager.onStop(e)}offStart(e){this.lifecycleManager.offStart(e)}offStop(e){this.lifecycleManager.offStop(e)}sendCloseAppRequest(e){this.getProxy().tryCloseApp(e,!1)}sendError(e,t){this.logger.error(e,t)}sendFatalError(e,t){this.getProxy().tryCloseApp(e,!0,t?m(t):void 0)}subscribe(e,t){this.getProxy().subscribe(e,t)}unsubscribe(e,t){this.getProxy().unsubscribe(e,t)}publish(e,t){this.getProxy().publish(e,m(t))}}var _;(function(i){i.CurrentContactId="CURRENT_CONTACT"})(_||(_={}));class fe extends D{constructor(e){super(e)}handleLifecycleChangeMessage(e){const t=new z({provider:this.provider,instanceId:e.instanceId,config:e.config});this.state.appInstanceId=e.appInstanceId,this.state.instanceId=e.instanceId,this.state.appConfig=e.appConfig,this.state.config=e.config;const n={context:t};switch(e.stage){case"create":return this.handleCreate(n);default:return this.logger.error("Attempted to send invalid stage to service",{stage:e.stage}),Promise.reject(new Error("Invalid stage sent to service. Are you using AmazonConnectService for a 3P app? Use AmazonConnectApp"))}}}class w extends x{constructor(e){super({config:e,proxyFactory:()=>this.createProxy()}),this.lifecycleManager=new fe(this),this.logger=new g({provider:this,source:"app.provider"})}static init(e){const t=new w(e);return w.initializeProvider(t),{provider:t}}static get default(){return y("AmazonConnectService has not been initialized")}createProxy(){return new R(this,this.lifecycleManager)}sendError(e,t){this.logger.error(e,t)}sendFatalError(e,t){this.getProxy().sendServiceError(e,t?m(t):void 0)}subscribe(e,t){this.getProxy().subscribe(e,t)}unsubscribe(e,t){this.getProxy().unsubscribe(e,t)}publish(e,t){this.getProxy().publish(e,m(t))}}class z extends H{constructor({provider:e,instanceId:t,config:n}){super(e),this.instanceId=t,this.config=n}}const ye=Object.freeze(Object.defineProperty({__proto__:null,AmazonConnectApp:C,AmazonConnectService:w,get AppContactScope(){return _},AppContext:k,ServiceContext:z},Symbol.toStringTag,{value:"Module"}));f.AmazonConnectApp=ye,Object.defineProperty(f,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=amazon-connect-app.umd.js.map
